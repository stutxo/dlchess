pub fn verify_all_outcomes(&self, attestations: &GameAttestations) {
    let outcomes = [
        ("White", &attestations.white, 0),
        ("Black", &attestations.black, 1),
        ("Draw", &attestations.draw, 2),
    ];

    for (name, attestation, index) in outcomes.iter() {
        if let Some(decryption_key) = self.verify_and_decrypt_with_index(attestation, *index, name)
        {
            println!("{} outcome decryption key: {}", name, decryption_key);
        } else {
            println!("{} outcome attestation verification failed.", name);
        }
    }
}

pub fn verify_and_decrypt_with_index(
    &self,
    attestation: &Attestation,
    index: usize,
    name: &str,
) -> Option<Scalar> {
    let message = Message::<Public>::plain("text-bitcoin", &attestation.message);

    if !self.schnorr.verify_encrypted_signature(
        &self.signing_keypair.public_key(),
        &attestation.key,
        message,
        &attestation.adaptor_sig,
    ) {
        return None;
    }

    //step 1 is share all 3 of these keys with players so they can use it to build the tapscript paths
    println!("{} encrypted key: {}", name, attestation.key);

    //step 2 is share the result of the game by sending this signature
    let signature = self
        .schnorr
        .decrypt_signature(self.secret_keys[index], attestation.adaptor_sig.clone());

    //step 3 is players run this to get the decryption key to unlock the script
    self.schnorr
        .recover_decryption_key(&attestation.key, &attestation.adaptor_sig, &signature)
}
